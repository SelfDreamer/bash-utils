#!/usr/bin/env bash

function cmd_pager() {
    
    local has_bat=false
    if command -v bat &>/dev/null; then has_bat=true; fi

    function show_usage() {
        function p_opt() { printf "  %-42s %s\n" "$1" "$2"; }
        function p_sec() { printf "\n%s\n" "$1"; }

        cat <<EOF
Usage: cmd_pager [<file>] [flags]

A robust, boxed file pager (TTY Safe Edition).

Arguments:
  [<file>]                                   The file to display (stdin if empty)

Flags:
EOF
        p_opt "-h, --help" "Show context-sensitive help."
        p_opt "    --show-line-numbers" "Show line numbers."
        p_opt "    --[no-]soft-wrap" "Soft wrap lines (Default: true)."
        p_opt "    --plain" "Treat content as plain text (no ANSI)."
        p_opt "    --timeout=0" "Timeout until command exits (e.g. 5s)."
        p_opt "    --scroll-step=1" "Lines to scroll per tick."
        p_opt "    --tab-width=4" "Number of spaces per tab."

        p_sec "Layout & Window"
        p_opt "    --title=\"\"" "Window title text."
        p_opt "    --title.align=\"center\"" "Align: left, center, right."
        p_opt "    --border=\"rounded\"" "Style: rounded, normal, double, thick, hidden."
        p_opt "    --separator=\"│\"" "Character for the vertical separator."
        p_opt "    --line-number.pad=\"0 1\"" "Padding (Left Right) for numbers."
        p_opt "    --separator.pad=\"1 1\"" "Padding (Left Right) for separator."

        if [[ "$has_bat" == "true" ]]; then
            p_sec "Bat Integration"
            p_opt "    --theme=\"\"" "Bat syntax theme."
            p_opt "    --language=\"\"" "Force specific language syntax."
        fi

        p_sec "Style Flags (Colors: Hex, RGB 'r;g;b', ANSI)"
        p_opt "    --foreground=\"\"" "Global text foreground."
        p_opt "    --background=\"\"" "Global text background."
        p_opt "    --border.foreground=\"238\"" "Border foreground."
        p_opt "    --border.background=\"\"" "Border background."
        p_opt "    --title.foreground=\"\"" "Title foreground."
        p_opt "    --title.background=\"\"" "Title background."
        p_opt "    --line-number.foreground=\"237\"" "Line number foreground."
        p_opt "    --line-number.background=\"\"" "Line number background."
        p_opt "    --separator.foreground=\"238\"" "Separator foreground."
        p_opt "    --separator.background=\"\"" "Separator background."
        p_opt "    --footer.foreground=\"241\"" "Footer foreground."
        p_opt "    --footer.background=\"\"" "Footer background."
        p_opt "    --match.foreground=\"212\"" "Search match text."
        p_opt "    --match.background=\"\"" "Search match background."
        p_opt "    --match-highlight.foreground=\"235\"" "Current match text."
        p_opt "    --match-highlight.background=\"225\"" "Current match background."
        p_opt "    --help.foreground=\"\"" "Help text foreground."
        p_opt "    --empty.foreground=\"237\"" "Empty line tilde (~) color."

        p_sec "Style Modes (Suffixes)"
        echo "  Apply to any element (e.g. --border.bold, --title.italic):"
        echo "  .bold, .dim, .italic, .underline, .blink, .reverse"
        echo ""
    }

    function get_style_seq() {
        local type="$1"; local code="$2"
        if [[ -z "$code" ]]; then echo ""; return; fi
        
        local rgb_regex="^[0-9]{1,3};[0-9]{1,3};[0-9]{1,3}$"
        case "$type" in
            mode) case "$code" in 
                    bold) echo -ne "\033[1m";; 
                    dim) echo -ne "\033[2m";; 
                    italic) echo -ne "\033[3m";; 
                    underline) echo -ne "\033[4m";; 
                    blink) echo -ne "\033[5m";; 
                    reverse) echo -ne "\033[7m";; 
                    strike) echo -ne "\033[9m";; 
                  esac ;;
            fg|bg)
                local prefix="38"; [[ "$type" == "bg" ]] && prefix="48"
                if [[ "$code" =~ $rgb_regex ]]; then echo -ne "\033[${prefix};2;${code}m"
                elif [[ "$code" =~ ^[0-9]+$ ]]; then echo -ne "\033[${prefix};5;${code}m"
                fi ;;
        esac
    }

    local show_line_numbers=false
    local wrap_text=true
    local plain_mode=false
    local timeout_sec=0
    local input_file=""
    local original_filename=""
    local show_help=false
    local scroll_step=1
    local tab_width=4
    
    local title_raw=""
    local title_align="center" 
    local border_style="rounded"
    local separator_char="│"

    local bat_theme=""
    local bat_lang=""
    local manual_color_set=false

    local pad_num_l=0; local pad_num_r=1
    local pad_sep_l=1; local pad_sep_r=1

    local modes_text=""
    local c_text_fg="" c_text_bg=""
    
    local modes_num=""
    local c_num_fg=$(get_style_seq "fg" "237") c_num_bg=""
    
    local modes_border=""
    local c_border_fg=$(get_style_seq "fg" "238") c_border_bg=""
    
    local modes_title=""
    local c_title_fg="" c_title_bg=""
    
    local modes_sep=""
    local c_sep_fg=$(get_style_seq "fg" "238") c_sep_bg=""
    
    local modes_footer=""
    local c_footer_fg=$(get_style_seq "fg" "241") c_footer_bg=""
    
    local c_empty_fg=$(get_style_seq "fg" "237")
    local c_match_fg=$(get_style_seq "fg" "212") c_match_bg=""
    local c_match_hi_fg=$(get_style_seq "fg" "235") c_match_hi_bg=$(get_style_seq "bg" "225")
    local c_error_fg=$(get_style_seq "fg" "196")

    local args_files=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)           show_usage; return 0 ;;
            --show-line-numbers) show_line_numbers=true; shift ;;
            --soft-wrap)         wrap_text=true; shift ;;
            --no-soft-wrap)      wrap_text=false; shift ;;
            --plain)             plain_mode=true; shift ;;
            --timeout=*)         timeout_sec="${1#*=}"; shift ;;
            --scroll-step=*)     scroll_step="${1#*=}"; shift ;;
            --tab-width=*)       tab_width="${1#*=}"; shift ;;

            --line-number.pad=*) 
                read -r pad_num_l pad_num_r <<< "${1#*=}"
                [[ -z "$pad_num_l" ]] && pad_num_l=0; [[ -z "$pad_num_r" ]] && pad_num_r=0
                shift ;;
            --separator.pad=*)   
                read -r pad_sep_l pad_sep_r <<< "${1#*=}"
                [[ -z "$pad_sep_l" ]] && pad_sep_l=0; [[ -z "$pad_sep_r" ]] && pad_sep_r=0
                shift ;;

            --title=*)           title_raw="${1#*=}"; shift ;;
            --title.align=*)     title_align="${1#*=}"; shift ;;
            --border=*)          border_style="${1#*=}"; shift ;;
            --separator)         separator_char="$2"; shift 2 ;;
            --separator=*)       separator_char="${1#*=}"; shift ;;

            --theme=*)           bat_theme="${1#*=}"; shift ;;
            --language=*)        bat_lang="${1#*=}"; shift ;;

            --foreground=*)      c_text_fg=$(get_style_seq "fg" "${1#*=}"); manual_color_set=true; shift ;;
            --background=*)      c_text_bg=$(get_style_seq "bg" "${1#*=}"); manual_color_set=true; shift ;;
            --bold)              modes_text+=$(get_style_seq "mode" "bold"); shift ;;
            --dim)               modes_text+=$(get_style_seq "mode" "dim"); shift ;;
            --italic)            modes_text+=$(get_style_seq "mode" "italic"); shift ;;
            --underline)         modes_text+=$(get_style_seq "mode" "underline"); shift ;;
            
            --border.foreground=*) c_border_fg=$(get_style_seq "fg" "${1#*=}"); shift ;;
            --border.background=*) c_border_bg=$(get_style_seq "bg" "${1#*=}"); shift ;;
            --border.bold)         modes_border+=$(get_style_seq "mode" "bold"); shift ;;
            --border.dim)          modes_border+=$(get_style_seq "mode" "dim"); shift ;;
            --border.italic)       modes_border+=$(get_style_seq "mode" "italic"); shift ;;
            --border.underline)    modes_border+=$(get_style_seq "mode" "underline"); shift ;;
            
            --title.foreground=*) c_title_fg=$(get_style_seq "fg" "${1#*=}"); shift ;;
            --title.background=*) c_title_bg=$(get_style_seq "bg" "${1#*=}"); shift ;;
            --title.bold)         modes_title+=$(get_style_seq "mode" "bold"); shift ;;
            --title.dim)          modes_title+=$(get_style_seq "mode" "dim"); shift ;;
            --title.italic)       modes_title+=$(get_style_seq "mode" "italic"); shift ;;
            --title.underline)    modes_title+=$(get_style_seq "mode" "underline"); shift ;;
            --title.reverse)      modes_title+=$(get_style_seq "mode" "reverse"); shift ;;
            
            --line-number.foreground=*) c_num_fg=$(get_style_seq "fg" "${1#*=}"); shift ;;
            --line-number.background=*) c_num_bg=$(get_style_seq "bg" "${1#*=}"); shift ;;
            --line-number.bold)         modes_num+=$(get_style_seq "mode" "bold"); shift ;;
            --line-number.dim)          modes_num+=$(get_style_seq "mode" "dim"); shift ;;
            --line-number.italic)       modes_num+=$(get_style_seq "mode" "italic"); shift ;;
            --line-number.underline)    modes_num+=$(get_style_seq "mode" "underline"); shift ;;
            
            --separator.foreground=*)   c_sep_fg=$(get_style_seq "fg" "${1#*=}"); shift ;;
            --separator.background=*)   c_sep_bg=$(get_style_seq "bg" "${1#*=}"); shift ;;
            --separator.bold)           modes_sep+=$(get_style_seq "mode" "bold"); shift ;;
            --separator.dim)            modes_sep+=$(get_style_seq "mode" "dim"); shift ;;
            --separator.italic)         modes_sep+=$(get_style_seq "mode" "italic"); shift ;;
            --separator.underline)      modes_sep+=$(get_style_seq "mode" "underline"); shift ;;
            --separator.reverse)        modes_sep+=$(get_style_seq "mode" "reverse"); shift ;;
            
            --footer.foreground=*)      c_footer_fg=$(get_style_seq "fg" "${1#*=}"); shift ;;
            --footer.background=*)      c_footer_bg=$(get_style_seq "bg" "${1#*=}"); shift ;;
            --footer.bold)              modes_footer+=$(get_style_seq "mode" "bold"); shift ;;
            --footer.dim)               modes_footer+=$(get_style_seq "mode" "dim"); shift ;;
            --footer.italic)            modes_footer+=$(get_style_seq "mode" "italic"); shift ;;
            --footer.underline)         modes_footer+=$(get_style_seq "mode" "underline"); shift ;;
            
            --help.foreground=*)        c_footer_fg=$(get_style_seq "fg" "${1#*=}"); shift ;; 
            --empty.foreground=*)       c_empty_fg=$(get_style_seq "fg" "${1#*=}"); shift ;;
            
            --match.foreground=*)            c_match_fg=$(get_style_seq "fg" "${1#*=}"); shift ;;
            --match.background=*)            c_match_bg=$(get_style_seq "bg" "${1#*=}"); shift ;;
            --match-highlight.foreground=*) c_match_hi_fg=$(get_style_seq "fg" "${1#*=}"); shift ;;
            --match-highlight.background=*) c_match_hi_bg=$(get_style_seq "bg" "${1#*=}"); shift ;;
            
            -*) echo "Error: Unknown flag '$1'" >&2; echo "Run with --help for usage." >&2; return 1 ;;
            *)  args_files+=("$1"); shift ;;
        esac
    done

    if [[ ! "$border_style" =~ ^(rounded|normal|double|thick|hidden)$ ]]; then
        echo "Error: Invalid border style '$border_style'." >&2
        echo "Valid options: rounded, normal, double, thick, hidden." >&2
        return 1
    fi

    if [[ ! "$title_align" =~ ^(left|center|right)$ ]]; then
        echo "Error: Invalid title alignment '$title_align'." >&2
        echo "Valid options: left, center, right." >&2
        return 1
    fi

    [[ -z "$c_title_fg" ]] && c_title_fg="$c_border_fg"
    [[ -z "$c_title_bg" ]] && c_title_bg="$c_border_bg"

    local tmp_file=""
    if [[ ${#args_files[@]} -gt 0 ]]; then
        input_file="${args_files[0]}"
        original_filename="$input_file"
        if [[ ! -f "$input_file" ]]; then echo "gum: file not found: $input_file" >&2; return 1; fi
        [[ -z "$title_raw" ]] && title_raw=" $(basename "$original_filename") "
    else
        if [ ! -t 0 ]; then
            tmp_file=$(mktemp)
            cat > "$tmp_file"
            input_file="$tmp_file"
            
            local real_source=""
            if [[ -L "/dev/stdin" ]]; then
                real_source=$(readlink -f /dev/stdin 2>/dev/null)
            fi
            if [[ -n "$real_source" && -f "$real_source" ]]; then
                original_filename=$(basename "$real_source")
            else
                original_filename="Input"
            fi
            
            exec 0< /dev/tty
            [[ -z "$title_raw" ]] && title_raw=" $original_filename "
        else
            show_usage; return 1
        fi
    fi

    local processed_file=""
    if [[ "$plain_mode" == "false" && -n "$bat_theme" && "$manual_color_set" == "false" && "$has_bat" == "true" ]]; then
        processed_file=$(mktemp)
        local bat_cmd=("bat" "--color=always" "--style=plain" "--theme=$bat_theme" "--tabs=$tab_width")
        [[ -n "$bat_lang" ]] && bat_cmd+=("-l" "$bat_lang")
        
        if [[ -f "$original_filename" && "$original_filename" != "stdin" && "$original_filename" != "Input" ]]; then
            "${bat_cmd[@]}" "$original_filename" > "$processed_file" 2>/dev/null
        else
            "${bat_cmd[@]}" "$input_file" > "$processed_file" 2>/dev/null
        fi
        if [[ -s "$processed_file" ]]; then input_file="$processed_file"; fi
    fi

    local b_tl="╭" b_tr="╮" b_bl="╰" b_br="╯" b_h="─" b_v="│"
    case "$border_style" in
        normal) b_tl="┌"; b_tr="┐"; b_bl="└"; b_br="┘"; b_h="─"; b_v="│" ;;
        double) b_tl="╔"; b_tr="╗"; b_bl="╚"; b_br="╝"; b_h="═"; b_v="║" ;;
        thick)  b_tl="┏"; b_tr="┓"; b_bl="┗"; b_br="┛"; b_h="━"; b_v="┃" ;;
        hidden) b_tl=" "; b_tr=" "; b_bl=" "; b_br=" "; b_h=" "; b_v=" " ;;
    esac

    if [[ "$timeout_sec" != "0" && -n "$timeout_sec" ]]; then
        local sec=${timeout_sec%s}
        ( sleep "$sec" && kill -TERM $$ 2>/dev/null ) &
        local timeout_pid=$!
        trap "kill $timeout_pid 2>/dev/null" EXIT
    fi

    function _pager_cleanup() {
        if command -v tput &>/dev/null; then tput rmcup > /dev/tty; else echo -ne "\033[?1049l" > /dev/tty; fi
        echo -ne "\033[?25h\033[?7h\033[?1l\033>" > /dev/tty
        
        [[ -n "$tmp_file" && -f "$tmp_file" ]] && rm -f "$tmp_file"
        [[ -n "$processed_file" && -f "$processed_file" ]] && rm -f "$processed_file"
        
        stty sane < /dev/tty
    }
    trap '_pager_cleanup; exit 0' EXIT INT TERM

    local setup_seq="\033[?25l\033[?7l\033[?1049h"
    echo -ne "$setup_seq" >&2
    
    local scroll_offset=0
    local total_lines=$(wc -l < "$input_file")
    [[ -s "$input_file" && "$total_lines" -eq 0 ]] && total_lines=1
    
    local search_query=""
    local regex_pattern=""
    local search_matches=()
    local match_index=-1
    local status_msg=""
    local status_color=""

    local s_text="${modes_text}${c_text_fg}${c_text_bg}"
    local s_border="${modes_border}${c_border_fg}${c_border_bg}"
    local s_title="${modes_title}${c_title_fg}${c_title_bg}"
    local s_num="${modes_num}${c_num_fg}${c_num_bg}"
    local s_sep="${modes_sep}${c_sep_fg}${c_sep_bg}"
    local s_footer="${modes_footer}${c_footer_fg}${c_footer_bg}"
    local s_empty="${c_empty_fg}"
    local s_match="${c_match_fg}${c_match_bg}" 
    local s_match_hi="${c_match_hi_fg}${c_match_hi_bg}" 
    local s_error="${c_error_fg}"
    local reset="\033[0m"

    while true; do
        local term_rows=$(tput lines)
        local term_cols=$(tput cols)
        
        local content_height=$((term_rows - 2))
        local content_width=$((term_cols - 2))
        
        if [[ $content_height -lt 1 || $content_width -lt 1 ]]; then
            echo -ne "\033[HTerminal too small" >&2; read -rsn1 < /dev/tty; break
        fi

        if [[ "$show_help" == "true" ]]; then
            echo -ne "\033[H\033[2J" >&2
            echo -e "\n ${s_border}Help:${reset}" >&2
            echo -e "  j / ↓   : Scroll Down" >&2
            echo -e "  k / ↑   : Scroll Up" >&2
            echo -e "  /        : Search" >&2
            echo -e "  n / N   : Next/Prev Match" >&2
            echo -e "  ESC      : Clear Search / Quit" >&2
            echo -e "\n ${s_footer}Press any key to return...${reset}" >&2
            read -rsn1 < /dev/tty; show_help=false; continue
        fi        

        local num_width=0
        if [[ "$show_line_numbers" == "true" ]]; then num_width=${#total_lines}; fi

        echo -ne "\033[H" >&2
        
        local title_vis=$(sed 's/\x1b\[[0-9;]*m//g' <<< "$title_raw")
        local title_len=${#title_vis}
        local avail_space=$((term_cols - 2))
        
        if [[ -n "$title_raw" ]]; then
            local filler_len=$((avail_space - title_len))
            [[ $filler_len -lt 0 ]] && filler_len=0
            
            echo -ne "${s_border}${b_tl}" >&2
            
            case "$title_align" in
                left)
                    echo -ne "${reset}${s_title}${title_raw}${reset}${s_border}" >&2
                    for ((i=0; i<filler_len; i++)); do echo -ne "${b_h}" >&2; done ;;
                right)
                    for ((i=0; i<filler_len; i++)); do echo -ne "${b_h}" >&2; done
                    echo -ne "${reset}${s_title}${title_raw}${reset}${s_border}" >&2 ;;
                center)
                    local pad_l=$((filler_len / 2)); local pad_r=$((filler_len - pad_l))
                    for ((i=0; i<pad_l; i++)); do echo -ne "${b_h}" >&2; done
                    echo -ne "${reset}${s_title}${title_raw}${reset}${s_border}" >&2
                    for ((i=0; i<pad_r; i++)); do echo -ne "${b_h}" >&2; done ;;
            esac
            echo -ne "${b_tr}${reset}\n" >&2
        else
            echo -ne "${s_border}${b_tl}" >&2
            for ((i=0; i<avail_space; i++)); do echo -ne "${b_h}" >&2; done
            echo -ne "${b_tr}${reset}\n" >&2
        fi

        local safe_search="${regex_pattern//\\/\\\\}"
        
        awk -v OFFSET="$scroll_offset" \
            -v HEIGHT="$content_height" \
            -v WIDTH="$content_width" \
            -v SHOW_NUM="$show_line_numbers" \
            -v NUM_W="$num_width" \
            -v SEARCH="$safe_search" \
            -v WRAP="$wrap_text" \
            -v PLAIN="$plain_mode" \
            -v SEP_CHAR="$separator_char" \
            -v S_NUM="$s_num" \
            -v S_SEP="$s_sep" \
            -v S_TXT="$s_text" \
            -v S_MATCH="$s_match" \
            -v S_MATCH_HI="$s_match_hi" \
            -v S_BORD="$s_border" \
            -v S_EMPTY="$s_empty" \
            -v B_V="$b_v" \
            -v RESET="$reset" \
            -v P_NL="$pad_num_l" \
            -v P_NR="$pad_num_r" \
            -v P_SL="$pad_sep_l" \
            -v P_SR="$pad_sep_r" \
            '
            function strip_ansi(str) { gsub(/\033\[[0-9;?]*[a-zA-Z]/, "", str); return str }
            function visible_length(str) { return length(strip_ansi(str)) }
            function get_cut_index(str, max_vis,    len_str, idx, vis_count, char, chunk, match_len) {
                len_str = length(str); vis_count = 0; idx = 1
                while (idx <= len_str && vis_count < max_vis) {
                    chunk = substr(str, idx)
                    if (match(chunk, /^\033\[[0-9;?]*[a-zA-Z]/)) { idx += RLENGTH } else { idx++; vis_count++ }
                }
                return idx - 1
            }
            function build_prefix(l_no, is_empty, is_cont) {
                if (SHOW_NUM != "true") return S_TXT;
                pad_nl_str = sprintf("%"P_NL"s", ""); pad_nr_str = sprintf("%"P_NR"s", "")
                pad_sl_str = sprintf("%"P_SL"s", ""); pad_sr_str = sprintf("%"P_SR"s", "")
                
                content = sprintf("%"NUM_W"d", l_no)
                if (is_empty) content = sprintf("%"NUM_W"s", "~")
                if (is_cont)  content = sprintf("%"NUM_W"s", "")
                
                return S_NUM pad_nl_str content pad_nr_str RESET pad_sl_str S_SEP SEP_CHAR RESET pad_sr_str S_TXT
            }
            function print_line(txt, l_no, is_empty, is_cont) {
                pfx = build_prefix(l_no, is_empty, is_cont)
                printf "%s%s%s%s%s", S_BORD, B_V, RESET, pfx, txt
                vis_len = visible_length(pfx) + visible_length(txt)
                padding = WIDTH - vis_len
                if (padding < 0) padding = 0
                if (padding > 0) printf "%"padding"s", ""
                printf "%s%s%s%s\n", RESET, S_BORD, B_V, RESET
            }
            BEGIN { printed=0 }
            {
                if (printed >= HEIGHT) exit
                if (NR <= OFFSET) next
                raw = $0
                if (PLAIN == "true") raw = strip_ansi(raw)
                
                # Highlight search match
                if (SEARCH != "") gsub(SEARCH, S_MATCH "&" RESET S_TXT, raw)
                
                plen = 0
                if (SHOW_NUM == "true") plen = P_NL + NUM_W + P_NR + P_SL + 1 + P_SR
                max = WIDTH - plen; if (max < 1) max = 1
                
                if (WRAP == "true" && visible_length(raw) > max) {
                    line = raw; is_c = 0
                    while (visible_length(line) > max) {
                        cut_at = get_cut_index(line, max)
                        chunk = substr(line, 1, cut_at)
                        print_line(chunk RESET, NR, 0, is_c)
                        printed++; if (printed >= HEIGHT) exit
                        line = substr(line, cut_at + 1); is_c = 1 
                    }
                    if (printed < HEIGHT && length(line) > 0) { print_line(line, NR, 0, is_c); printed++ }
                } else {
                    if (visible_length(raw) > max) {
                        cut_at = get_cut_index(raw, max)
                        raw = substr(raw, 1, cut_at)
                        raw = raw RESET S_EMPTY "…"
                    }
                    print_line(raw, NR, 0, 0); printed++
                }
            }
            END { while (printed < HEIGHT) { print_line("", 0, 1, 0); printed++ } }
            ' "$input_file" >&2

        local percent=100
        if (( total_lines > 0 )); then
            local end_line=$(( scroll_offset + viewport_height ))
            [[ $end_line -gt $total_lines ]] && end_line=$total_lines
            percent=$(( end_line * 100 / total_lines ))
        fi
        
        local info_txt=" ${percent}% • ${scroll_offset}/${total_lines} "
        if [[ -n "$status_msg" ]]; then info_txt=" ${status_msg} "; fi
        
        local info_len=${#info_txt}
        local avail_space=$((term_cols - 2))
        local filler_len=$((avail_space - info_len))
        local pad_l=$((filler_len / 2))
        local pad_r=$((filler_len - pad_l))
        
        echo -ne "${s_border}${b_bl}" >&2
        for ((i=0; i<pad_l; i++)); do echo -ne "${b_h}" >&2; done
        echo -ne "${reset}${s_footer}${info_txt}${reset}${s_border}" >&2
        for ((i=0; i<pad_r; i++)); do echo -ne "${b_h}" >&2; done
        echo -ne "${b_br}${reset}" >&2

        read -rsn1 key < /dev/tty
        if [[ $key == $'\x1b' ]]; then
            read -rsn2 -t 0.01 key < /dev/tty
            if [[ -z "$key" ]]; then
                if [[ -n "$regex_pattern" ]]; then
                    regex_pattern=""
                    search_matches=()
                    status_msg=""
                else
                    break
                fi
            else
                case "$key" in '[A') ((scroll_offset -= scroll_step));; '[B') ((scroll_offset += scroll_step));; '[H'|'OH') scroll_offset=0;; '[F'|'OF') scroll_offset=$((total_lines - content_height));; esac
            fi
        else
            case "$key" in
                "q"|$'\03') break ;;
                "j"|"J") ((scroll_offset += scroll_step)) ;;
                "k"|"K") ((scroll_offset -= scroll_step)) ;;
                "d") ((scroll_offset += content_height / 2)) ;;
                "u") ((scroll_offset -= content_height / 2)) ;;
                "g") scroll_offset=0 ;;
                "G") scroll_offset=$((total_lines - content_height)) ;;
                "?"|"h") show_help=true ;;
                "/") 
                    echo -ne "\r\033[K${s_footer}/${reset}" >&2; echo -ne "\033[?25h" >&2
                    local q=""; while true; do read -rsn1 c < /dev/tty; if [[ "$c" == "" ]]; then break; elif [[ "$c" == $'\x7f' ]]; then [[ -n "$q" ]] && q="${q%?}" && echo -ne "\b \b" >&2; elif [[ "$c" == $'\x1b' ]]; then q=""; break; else q+="$c"; echo -ne "$c" >&2; fi; done
                    echo -ne "\033[?25l" >&2
                    if [[ -n "$q" ]]; then regex_pattern="$q"; mapfile -t search_matches < <(grep -nE "$q" "$input_file" 2>/dev/null | cut -d: -f1); if [[ ${#search_matches[@]} -eq 0 ]]; then status_msg="Not found"; status_color="$s_error"; regex_pattern=""; else match_index=0; scroll_offset=$((${search_matches[0]} - 1)); status_msg="Found ${#search_matches[@]}"; fi; fi ;;
                "n") [[ ${#search_matches[@]} -gt 0 ]] && { ((match_index++)); [[ $match_index -ge ${#search_matches[@]} ]] && match_index=0; scroll_offset=$((${search_matches[$match_index]} - 1)); } ;;
                "N") [[ ${#search_matches[@]} -gt 0 ]] && { ((match_index--)); [[ $match_index -lt 0 ]] && match_index=$((${#search_matches[@]} - 1)); scroll_offset=$((${search_matches[$match_index]} - 1)); } ;;
            esac
        fi
        
        [[ $scroll_offset -lt 0 ]] && scroll_offset=0
        local max_off=$((total_lines - content_height))
        if (( max_off < 0 )); then max_off=0; fi
        [[ $scroll_offset -gt $max_off ]] && scroll_offset=$max_off
    done
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    cmd_pager "${@}"
fi
