#!/usr/bin/env bash

function cmd_confirm() {
    
    function make_ansi() {
        local fg=$1; local bg=$2; local seq=""
        [[ -n "$fg" ]] && seq+="\e[38;5;${fg}m"
        [[ -n "$bg" ]] && seq+="\e[48;5;${bg}m"
        echo "$seq"
    }

    local prompt="Are you sure?"
    local aff_text="Yes"
    local neg_text="No"
    local default_choice="Yes" 
    local timeout=0 
    local show_output=false
    local show_help_footer=true
    
    local c_prompt_fg=""        ; local c_prompt_bg=""
    local c_sel_fg="255"        ; local c_sel_bg="212"  
    local c_unsel_fg="240"      ; local c_unsel_bg=""   
    
    local col_msg=$'\e[38;2;95;95;95m'
    local col_reset=$'\e[0m'

    function show_help_panel() {
        cat <<EOF
Usage: bash-utils confirm [<prompt>] [flags]

Ask a user to confirm an action

Arguments:
  [<prompt>]                 Prompt to display.

Flags:
  -h, --help                 Show context-sensitive help.
      --default              Default confirmation action (true/false or Yes/No)
      --show-output          Print prompt and chosen action to output
      --affirmative="Yes"    The title of the affirmative action
      --negative="No"        The title of the negative action
      --timeout=0            Timeout in seconds
      --no-show-help         Hide help key binds

Style Flags:
  --prompt.foreground        Foreground Color
  --prompt.background        Background Color
  --selected.foreground      Foreground Color
  --selected.background      Background Color
  --unselected.foreground    Foreground Color
  --unselected.background    Background Color
EOF
    }

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_help_panel; return 0 ;;
            
            --affirmative=*) aff_text="${1#*=}"; shift ;;
            --affirmative)   aff_text="$2"; shift 2 ;;
            
            --negative=*) neg_text="${1#*=}"; shift ;;
            --negative)   neg_text="$2"; shift 2 ;;
            
            --default=*) default_choice="${1#*=}"; shift ;;
            --default)   default_choice="$2"; shift 2 ;;
            
            --timeout=*) timeout="${1#*=}"; shift ;;
            --timeout)   timeout="$2"; shift 2 ;;
            
            --show-output) show_output=true; shift ;;
            --no-show-help) show_help_footer=false; shift ;;
            
            --prompt.foreground=*) c_prompt_fg="${1#*=}"; shift ;;
            --prompt.foreground)   c_prompt_fg="$2"; shift 2 ;;
            --prompt.background=*) c_prompt_bg="${1#*=}"; shift ;;
            --prompt.background)   c_prompt_bg="$2"; shift 2 ;;
            
            --selected.foreground=*) c_sel_fg="${1#*=}"; shift ;;
            --selected.foreground)   c_sel_fg="$2"; shift 2 ;;
            --selected.background=*) c_sel_bg="${1#*=}"; shift ;;
            --selected.background)   c_sel_bg="$2"; shift 2 ;;
            
            --unselected.foreground=*) c_unsel_fg="${1#*=}"; shift ;;
            --unselected.foreground)   c_unsel_fg="$2"; shift 2 ;;
            --unselected.background=*) c_unsel_bg="${1#*=}"; shift ;;
            --unselected.background)   c_unsel_bg="$2"; shift 2 ;;
            
            *) 
                if [[ "$1" == -* ]]; then
                    echo "Error: Unknown flag $1" >&2; return 1
                else
                    prompt="$1"; shift
                fi
                ;;
        esac
    done

    local selected_idx=0
    
    default_choice="${default_choice,,}" 
    if [[ "$default_choice" == "no" || "$default_choice" == "false" || "$default_choice" == "$neg_text" ]]; then
        selected_idx=1
    fi

    local style_prompt="$(make_ansi "$c_prompt_fg" "$c_prompt_bg")\e[1m"
    local style_sel="$(make_ansi "$c_sel_fg" "$c_sel_bg")\e[1m"
    local style_unsel="$(make_ansi "$c_unsel_fg" "$c_unsel_bg")"

    tput civis >&2 
    trap 'tput cnorm >&2' EXIT

    echo -e "${style_prompt}${prompt}${col_reset}" >&2
    
    function draw_buttons() {
        local buffer=""
        local pad="  " 
        
        if [[ $selected_idx -eq 0 ]]; then
            buffer+="${style_sel}${pad}${aff_text}${pad}${col_reset}"
        else
            buffer+="${style_unsel}${pad}${aff_text}${pad}${col_reset}"
        fi

        buffer+="    " 

        if [[ $selected_idx -eq 1 ]]; then
            buffer+="${style_sel}${pad}${neg_text}${pad}${col_reset}"
        else
            buffer+="${style_unsel}${pad}${neg_text}${pad}${col_reset}"
        fi
        
        echo -ne "\r${buffer}\e[K" >&2
    }

    draw_buttons
    
    if [[ "$show_help_footer" == "true" ]]; then
        echo "" >&2 
        echo -ne "${col_msg}←/→ toggle • y/n select${col_reset}\r\e[1A" >&2
    fi

    local start_time=$(date +%s)

    while true; do
        local read_timeout=""
        if [[ $timeout -gt 0 ]]; then
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            local remaining=$((timeout - elapsed))
            if [[ $remaining -le 0 ]]; then break; fi
            read_timeout="-t $remaining"
        fi

        IFS= read -rsn1 $read_timeout key
        local exit_code=$?

        if [[ $timeout -gt 0 && $exit_code -gt 128 ]]; then break; fi
        
        case "$key" in
            $'\x1b') 
                read -rsn2 -t 0.1 next_chars
                case "$next_chars" in
                    '[C'|'[D') ((selected_idx = 1 - selected_idx)); draw_buttons ;;
                esac
                ;;
            'h'|'l'|$'\t') 
                ((selected_idx = 1 - selected_idx))
                draw_buttons 
                ;;
            'y'|'Y') selected_idx=0; draw_buttons; break ;;
            'n'|'N') selected_idx=1; draw_buttons; break ;;
            "") break ;; 
            'q') 
                if [[ "$show_help_footer" == "true" ]]; then echo -ne "\n\e[2K\e[1A" >&2; fi
                echo -ne "\r\e[2K\e[1A\e[2K\r" >&2
                return 1 ;;
        esac
    done

    
    if [[ "$show_help_footer" == "true" ]]; then
        echo -ne "\n\e[2K\e[1A" >&2
    fi

    echo -ne "\r\e[2K" >&2

    echo -ne "\e[1A\e[2K\r" >&2

    tput cnorm >&2

    if [[ $selected_idx -eq 0 ]]; then
        [[ "$show_output" == "true" ]] && echo "$aff_text"
        return 0
    else
        [[ "$show_output" == "true" ]] && echo "$neg_text"
        return 1
    fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    cmd_confirm "${@}"
fi
