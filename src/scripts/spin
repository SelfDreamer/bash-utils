#!/usr/bin/env bash

function cmd_spin() {
    
    local ESC=$'\e' 
    local CR=$'\r'

    local VALID_SPINNERS=("dot" "line" "minidot" "jump" "pulse" "points" "globe" "moon" "monkey" "meter" "hamburger" "standard" "bar" "process")

    function make_ansi() {
        local fg=$1; local bg=$2; local seq=""
        [[ -n "$fg" ]] && seq+="${ESC}[38;5;${fg}m"
        [[ -n "$bg" ]] && seq+="${ESC}[48;5;${bg}m"
        echo "$seq"
    }

    local spinner_type="dot"
    local title="Loading..."
    local align="left"
    local timeout=0 
    local spin_delay="" 
    
    local show_output=false   
    local show_error=false    
    local show_stdout=false   
    local show_stderr=false   

    local c_spinner_fg="212"    
    local c_spinner_bg=""
    local c_title_fg=""         
    local c_title_bg=""
    
    function show_help_panel() {
        cat <<EOF
Usage: bash-utils spin <command> ... [flags]

Display spinner while running a command

Arguments:
  <command> ...           Command to run

Flags:
  -h, --help              Show context-sensitive help.
      --show-output       Show output (STDOUT+STDERR)
      --show-error        Show output only if command fails
      --show-stdout       Show STDOUT output
      --show-stderr       Show STDERR output
  -s, --spinner="dot"     Spinner type (dot, line, minidot, jump, pulse, points, globe, moon, monkey, meter, hamburger, standard, bar, process)
      --title="Loading..." Text to display
  -a, --align="left"      Alignment (left, right)
      --timeout=0s        Timeout in seconds
      --spin-delay=""     Custom delay

Style Flags:
  --spinner.foreground    Foreground Color
  --spinner.background    Background Color
  --title.foreground      Foreground Color
  --title.background      Background Color
EOF
    }

    local args_flags=()
    local user_cmd=()
    local found_dash=false

    for arg in "$@"; do
        if [[ "$found_dash" == "true" ]]; then
            user_cmd+=("$arg")
        elif [[ "$arg" == "--" ]]; then
            found_dash=true
        else
            args_flags+=("$arg")
        fi
    done

    set -- "${args_flags[@]}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_help_panel; return 0 ;;
            -s|--spinner) spinner_type="$2"; shift 2 ;;
            --spinner=*)  spinner_type="${1#*=}"; shift ;;
            --title)      title="$2"; shift 2 ;;
            --title=*)    title="${1#*=}"; shift ;;
            -a|--align)   align="$2"; shift 2 ;;
            --align=*)    align="${1#*=}"; shift ;;
            --timeout=*)  timeout="${1#*=}"; shift ;;
            --timeout)    timeout="$2"; shift 2 ;;
            --spin-delay=*) spin_delay="${1#*=}"; shift ;;
            --spin-delay)   spin_delay="$2"; shift 2 ;;
            --show-output) show_output=true; shift ;;
            --show-error)  show_error=true; shift ;;
            --show-stdout) show_stdout=true; shift ;;
            --show-stderr) show_stderr=true; shift ;;
            --spinner.foreground=*) c_spinner_fg="${1#*=}"; shift ;;
            --spinner.foreground)   c_spinner_fg="$2"; shift 2 ;;
            --spinner.background=*) c_spinner_bg="${1#*=}"; shift ;;
            --spinner.background)   c_spinner_bg="$2"; shift 2 ;;
            --title.foreground=*)   c_title_fg="${1#*=}"; shift ;;
            --title.foreground)     c_title_fg="$2"; shift 2 ;;
            --title.background=*)   c_title_bg="${1#*=}"; shift ;;
            --title.background)     c_title_bg="$2"; shift 2 ;;
            *) echo "gum: error: unknown flag $1"; return 1 ;;
        esac
    done

    if [[ ${#user_cmd[@]} -eq 0 ]]; then
        show_help_panel
        echo "" >&2
        echo "gum: error: expected <command> ..." >&2
        return 1
    fi

    local is_valid=false
    for v in "${VALID_SPINNERS[@]}"; do
        if [[ "$v" == "$spinner_type" ]]; then
            is_valid=true
            break
        fi
    done

    if [[ "$is_valid" == "false" ]]; then
        show_help_panel
        local list_str=""
        for v in "${VALID_SPINNERS[@]}"; do list_str+="\"$v\","; done
        list_str="${list_str%,}" 
        echo "" >&2
        echo "gum: error: --spinner must be one of ${list_str} but got \"${spinner_type}\"" >&2
        return 1
    fi

    timeout="${timeout%s}"

    local frames=()
    local suffixes=() 
    local default_delay=0.1

    case "$spinner_type" in
        line)      frames=("|" "/" "-" "\\"); default_delay=0.08 ;;
        standard)  frames=("[-]" "[/]" "[|]" "[\\]"); default_delay=0.1 ;;
        process)   frames=("[|]" "[/]" "[-]" "[\\]"); suffixes=("." ".." "..." "   "); default_delay=0.12 ;;
        bar)       frames=("[    ]" "[=   ]" "[==  ]" "[=== ]" "[====]" "[ ===]" "[  ==]" "[   =]" "[    ]"); default_delay=0.1 ;;
        minidot)   frames=("â ‹" "â ™" "â ¹" "â ¸" "â ¼" "â ´" "â ¦" "â §" "â ‡" "â "); default_delay=0.08 ;;
        jump)      frames=("â¢„" "â¢‚" "â¢" "â¡" "â¡ˆ" "â¡" "â¡ "); default_delay=0.1 ;;
        pulse)     frames=("â–ˆ" "â–“" "â–’" "â–‘"); default_delay=0.1 ;;
        points)    frames=("." ".." "..." "   "); default_delay=0.2 ;;
        globe)     frames=("ðŸŒ" "ðŸŒŽ" "ðŸŒ"); default_delay=0.2 ;;
        moon)      frames=("ðŸŒ‘" "ðŸŒ’" "ðŸŒ“" "ðŸŒ”" "ðŸŒ•" "ðŸŒ–" "ðŸŒ—" "ðŸŒ˜"); default_delay=0.1 ;;
        monkey)    frames=("ðŸ™ˆ" "ðŸ™‰" "ðŸ™Š"); default_delay=0.3 ;;
        meter)     frames=("â–±â–±â–±" "â–°â–±â–±" "â–°â–°â–±" "â–°â–°â–°" "â–°â–°â–±" "â–°â–±â–±"); default_delay=0.1 ;;
        hamburger) frames=("â˜²" "â˜´" "â˜µ" "â˜±" "â˜³"); default_delay=0.15 ;;
        dot|*)     frames=("â£¾" "â£½" "â£»" "â¢¿" "â¡¿" "â£Ÿ" "â£¯" "â£·"); default_delay=0.08 ;; 
    esac

    local delay="${spin_delay:-$default_delay}"

    local s_spinner="$(make_ansi "$c_spinner_fg" "$c_spinner_bg")"
    local s_title="$(make_ansi "$c_title_fg" "$c_title_bg")"
    local reset="${ESC}[0m"

    local temp_out
    local temp_err
    temp_out=$(mktemp)
    temp_err=$(mktemp)

    tput civis >&2 
    
    "${user_cmd[@]}" > "$temp_out" 2> "$temp_err" &
    local pid=$!
    local start_time=$(date +%s)

    trap 'kill $pid 2>/dev/null; printf "%s%s" "${CR}" "${ESC}[K" >&2; tput cnorm >&2; rm -f "$temp_out" "$temp_err"; return 130' SIGINT

    local i=0
    local total_frames=${#frames[@]}
    local total_suffixes=${#suffixes[@]}
    
    while kill -0 "$pid" 2>/dev/null; do
        if [[ $timeout -gt 0 ]]; then
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            if [[ $elapsed -ge $timeout ]]; then
                kill "$pid" 2>/dev/null
                break
            fi
        fi

        local frame="${frames[$i]}"
        local suffix=""
        if [[ $total_suffixes -gt 0 ]]; then
            suffix="${suffixes[$((i % total_suffixes))]}"
        fi
        
        local line=""
        if [[ "$align" == "right" ]]; then
            line="${s_title}${title}${suffix}${reset} ${s_spinner}${frame}${reset}"
        else
            line="${s_spinner}${frame}${reset} ${s_title}${title}${reset}${suffix}"
        fi

        printf "%s%s%s" "${CR}" "${line}" "${ESC}[K" >&2
        
        ((i = (i + 1) % total_frames))
        sleep "$delay"
    done

    wait "$pid" 2>/dev/null
    local exit_code=$?

    printf "%s%s" "${CR}" "${ESC}[K" >&2 
    tput cnorm >&2        

    if [[ "$show_output" == "true" ]]; then
        cat "$temp_out"
        cat "$temp_err" >&2
    else
        if [[ "$show_error" == "true" && $exit_code -ne 0 ]]; then
            cat "$temp_out"
            cat "$temp_err" >&2
        else
            if [[ "$show_stdout" == "true" ]]; then
                cat "$temp_out"
            fi
            if [[ "$show_stderr" == "true" ]]; then
                cat "$temp_err" >&2
            fi
        fi
    fi

    rm -f "$temp_out" "$temp_err"

    return $exit_code
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    cmd_spin "${@}"
fi
