#!/usr/bin/env bash

function cmd_table() {
    local ESC=$'\e'

    function make_ansi() {
        local fg=$1; local bg=$2; local attr=$3; local seq=""
        [[ -n "$attr" ]] && seq+="${ESC}[${attr}m"
        [[ -n "$fg" ]] && seq+="${ESC}[38;5;${fg}m"
        [[ -n "$bg" ]] && seq+="${ESC}[48;5;${bg}m"
        echo "$seq"
    }

    function check_literal() {
        local param_name="$1"; local value="$2"; shift 2; local options=("$@")
        local found=false
        for opt in "${options[@]}"; do
            if [[ "$value" == "$opt" ]]; then found=true; break; fi
        done
        if [[ "$found" == "false" ]]; then
            local list_str=$(IFS=, ; echo "${options[*]}")
            echo "gum: error: invalid value for --$param_name: \"$value\"" >&2
            echo "Valid options: $list_str" >&2
            return 1
        fi
        return 0
    }

    function parse_bool() {
        local val="${1,,}"
        if [[ "$val" == "true" || "$val" == "1" || "$val" == "yes" ]]; then echo "true"; else echo "false"; fi
    }

    function show_help_panel() {
        cat <<EOF
Usage: bash-utils table [flags]

Render a high-performance table of data using AWK.

Flags:
  -h, --help                Show help
  -s, --separator=","       Separator character
  -c, --columns="A,B,C"     Column titles (If omitted, first row is used as header)
  --align="left"            Table alignment (left, center, right)
  
  # Borders
  --border.type="rounded"   Type: "normal", "rounded", "thick", "double", "hidden"
  --border.style="default"  Style: "default", "rows", "mdcat"
  --border-foreground=240   Border foreground color
  --border-background=""    Border background color

  # Styles
  --header-foreground=212   Header text color
  --header-background=""    Header bg color
  --header.bold             Bold header
  --foreground=""           Cell text color
  --background=""           Cell bg color
  --foreground.bold         Bold cell text
  --foreground.underline    Underline cell text
EOF
    }

    local separator=","
    local columns=""
    local align="left"
    local border_fg="240"; local border_bg=""
    local header_fg="212"; local header_bg=""
    local h_bold="true"; local h_faint="false"; local h_italic="false"; local h_underline="false"; local h_strike="false"
    local cell_fg=""; local cell_bg=""
    local c_bold="false"; local c_faint="false"; local c_italic="false"; local c_underline="false"; local c_strike="false"
    local border_style="default"
    local border_type="rounded"

    local args_pos=()
    local parse_args=()
    
    while [[ $# -gt 0 ]]; do
        if [[ "$1" == --*=* ]]; then
            parse_args+=("${1%%=*}" "${1#*=}")
        else
            parse_args+=("$1")
        fi
        shift
    done
    set -- "${parse_args[@]}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_help_panel; return 0 ;;
            -s|--separator)   separator="$2"; shift 2 ;;
            -c|--columns)     columns="$2"; shift 2 ;;
            --align)          align="$2"; shift 2 ;;
            
            --border.style)   border_style="$2"; shift 2 ;;
            --border.type|--border)    border_type="$2"; shift 2 ;;
            --border-foreground)   border_fg="$2"; shift 2 ;;
            --border-background)   border_bg="$2"; shift 2 ;;
            
            --header-foreground)   header_fg="$2"; shift 2 ;;
            --header-background)   header_bg="$2"; shift 2 ;;
            --header.bold)         h_bold="true"; shift ;;
            --header.faint)        h_faint="true"; shift ;;
            --header.italic)       h_italic="true"; shift ;;
            --header.underline)    h_underline="true"; shift ;;
            --header.strikethrough) h_strike="true"; shift ;;
            
            --foreground)          cell_fg="$2"; shift 2 ;;
            --background)          cell_bg="$2"; shift 2 ;;
            --foreground.bold)     c_bold="true"; shift ;;
            --foreground.faint)    c_faint="true"; shift ;;
            --foreground.italic)   c_italic="true"; shift ;;
            --foreground.underline) c_underline="true"; shift ;;
            --foreground.strikethrough) c_strike="true"; shift ;;
            
            -*) echo "Error: unknown flag: $1" >&2; return 1 ;;
            *) shift ;;
        esac
    done

    check_literal "align" "$align" "left" "center" "right" || return 1
    check_literal "border.type" "$border_type" "normal" "rounded" "thick" "double" "hidden" || return 1
    check_literal "border.style" "$border_style" "default" "rows" "mdcat" || return 1

    declare -A B_NORM=( [tl]="┌" [t]="─" [tr]="┐" [tm]="┬" [l]="│" [m]="│" [r]="│" [ml]="├" [h]="─" [mm]="┼" [mr]="┤" [bl]="└" [b]="─" [br]="┘" [bm]="┴" )
    declare -A B_RND=(  [tl]="╭" [t]="─" [tr]="╮" [tm]="┬" [l]="│" [m]="│" [r]="│" [ml]="├" [h]="─" [mm]="┼" [mr]="┤" [bl]="╰" [b]="─" [br]="╯" [bm]="┴" )
    declare -A B_THICK=([tl]="┏" [t]="━" [tr]="┓" [tm]="┳" [l]="┃" [m]="┃" [r]="┃" [ml]="┣" [h]="━" [mm]="╋" [mr]="┫" [bl]="┗" [b]="━" [br]="┛" [bm]="┻" )
    declare -A B_DBL=(  [tl]="╔" [t]="═" [tr]="╗" [tm]="╦" [l]="║" [m]="║" [r]="║" [ml]="╠" [h]="═" [mm]="╬" [mr]="╣" [bl]="╚" [b]="═" [br]="╝" [bm]="╩" )
    declare -A B_HID=(  [tl]=" " [t]=" " [tr]=" " [tm]=" " [l]=" " [m]=" " [r]=" " [ml]=" " [h]=" " [mm]=" " [mr]=" " [bl]=" " [b]=" " [br]=" " [bm]=" " )

    local -n B
    case "$border_type" in
        normal) B=B_NORM ;;
        thick)  B=B_THICK ;;
        double) B=B_DBL ;;
        hidden) B=B_HID ;;
        *)      B=B_RND ;; 
    esac

    local attr_h=""
    [[ "$h_bold" == "true" ]] && attr_h+="1;"
    [[ "$h_faint" == "true" ]] && attr_h+="2;"
    [[ "$h_italic" == "true" ]] && attr_h+="3;"
    [[ "$h_underline" == "true" ]] && attr_h+="4;"
    [[ "$h_strike" == "true" ]] && attr_h+="9;"
    attr_h="${attr_h%;}"

    local attr_c=""
    [[ "$c_bold" == "true" ]] && attr_c+="1;"
    [[ "$c_faint" == "true" ]] && attr_c+="2;"
    [[ "$c_italic" == "true" ]] && attr_c+="3;"
    [[ "$c_underline" == "true" ]] && attr_c+="4;"
    [[ "$c_strike" == "true" ]] && attr_c+="9;"
    attr_c="${attr_c%;}"

    local s_head_bg=$(make_ansi "" "$header_bg" "")
    local s_head_txt=$(make_ansi "$header_fg" "" "$attr_h")
    local s_cell_bg=$(make_ansi "" "$cell_bg" "")
    local s_cell_txt=$(make_ansi "$cell_fg" "" "$attr_c")
    local s_border=$(make_ansi "$border_fg" "$border_bg" "")
    local reset="${ESC}[0m"
    local term_cols=$(tput cols 2>/dev/null || echo 80)

    cat - | awk -F "$separator" \
        -v COLUMNS_STR="$columns" \
        -v ALIGN="$align" \
        -v BORDER_STYLE="$border_style" \
        -v TERM_COLS="$term_cols" \
        -v S_BORDER="$s_border" \
        -v S_HEAD_BG="$s_head_bg" \
        -v S_HEAD_TXT="$s_head_txt" \
        -v S_CELL_BG="$s_cell_bg" \
        -v S_CELL_TXT="$s_cell_txt" \
        -v RESET="$reset" \
        -v B_TL="${B[tl]}" -v B_T="${B[t]}" -v B_TR="${B[tr]}" -v B_TM="${B[tm]}" \
        -v B_L="${B[l]}"   -v B_M="${B[m]}" -v B_R="${B[r]}" \
        -v B_ML="${B[ml]}" -v B_H="${B[h]}" -v B_MM="${B[mm]}" -v B_MR="${B[mr]}" \
        -v B_BL="${B[bl]}" -v B_B="${B[b]}" -v B_BR="${B[br]}" -v B_BM="${B[bm]}" \
    '
    function visible_length(str) {
        gsub(/\033\[[0-9;]*[a-zA-Z]/, "", str)
        return length(str)
    }
    function repeat(char, n,   res) {
        res = ""
        for (k=0; k<n; k++) res = res char
        return res
    }

    BEGIN {
        num_rows = 0
        explicit_header = 0
        has_header = 0
        
        if (COLUMNS_STR != "") {
            explicit_header = 1
            has_header = 1
            split(COLUMNS_STR, header_cells, ",")
            num_cols = length(header_cells)
            for (i=1; i<=num_cols; i++) {
                len = visible_length(header_cells[i])
                if (len > col_widths[i]) col_widths[i] = len
            }
        }
    }

    {
        if (NR == 1 && explicit_header == 0) {
            has_header = 1
            num_cols = NF
            for (i=1; i<=NF; i++) {
                header_cells[i] = $i
                len = visible_length($i)
                if (len > col_widths[i]) col_widths[i] = len
            }
            next
        }

        num_rows++
        if (NF > num_cols) num_cols = NF
        for (i=1; i<=NF; i++) {
            data[num_rows, i] = $i
            len = visible_length($i)
            if (len > col_widths[i]) col_widths[i] = len
        }
        for (i=NF+1; i<=num_cols; i++) data[num_rows, i] = ""
    }

    END {
        if (num_rows == 0 && has_header == 0) exit 0

        sum_widths = 0
        for (i=1; i<=num_cols; i++) sum_widths += col_widths[i]

        total_table_width = sum_widths + (3 * num_cols) + 1
        if (BORDER_STYLE == "mdcat") total_table_width = sum_widths + (3 * num_cols) - 1

        padding_spaces = 0
        if (ALIGN == "center") padding_spaces = int((TERM_COLS - total_table_width) / 2)
        else if (ALIGN == "right") padding_spaces = TERM_COLS - total_table_width
        if (padding_spaces < 0) padding_spaces = 0
        
        PAD_STR = sprintf("%" padding_spaces "s", "")

        if (has_header) {
            # Top Border (Skip for mdcat)
            if (BORDER_STYLE != "mdcat") {
                printf "%s%s%s", PAD_STR, S_BORDER, B_TL
                for (i=1; i<=num_cols; i++) {
                    printf "%s", repeat(B_T, col_widths[i]+2)
                    if (i < num_cols) printf "%s", B_TM
                }
                printf "%s%s\n", B_TR, RESET
            }

            printf "%s", PAD_STR
            if (BORDER_STYLE != "mdcat") printf "%s%s%s", S_BORDER, B_L, RESET
            
            for (i=1; i<=num_cols; i++) {
                val = header_cells[i]
                diff = col_widths[i] - visible_length(val)
                printf "%s %s%s%s%s%s%s ", S_HEAD_BG, S_HEAD_TXT, val, RESET, S_HEAD_BG, repeat(" ", diff), RESET
                if (i < num_cols) {
                    if (BORDER_STYLE == "mdcat") printf "%s%s%s", S_BORDER, B_L, RESET
                    else printf "%s%s%s", S_BORDER, B_M, RESET
                }
            }
            if (BORDER_STYLE != "mdcat") printf "%s%s%s", S_BORDER, B_R, RESET
            print ""

            printf "%s%s", PAD_STR, S_BORDER
            
            if (BORDER_STYLE != "mdcat") printf "%s", B_ML
            
            for (i=1; i<=num_cols; i++) {
                printf "%s", repeat(B_H, col_widths[i]+2)
                if (i < num_cols) printf "%s", B_MM
            }
            
            if (BORDER_STYLE != "mdcat") printf "%s", B_MR
            
            printf "%s\n", RESET

        } else if (BORDER_STYLE != "mdcat") {
             printf "%s%s%s", PAD_STR, S_BORDER, B_TL
             for (i=1; i<=num_cols; i++) {
                 printf "%s", repeat(B_T, col_widths[i]+2)
                 if (i < num_cols) printf "%s", B_TM
             }
             printf "%s%s\n", B_TR, RESET
        }

        for (r=1; r<=num_rows; r++) {
            if (r > 1 && BORDER_STYLE == "rows") {
                printf "%s%s%s", PAD_STR, S_BORDER, B_ML
                for (i=1; i<=num_cols; i++) {
                    printf "%s", repeat(B_H, col_widths[i]+2)
                    if (i < num_cols) printf "%s", B_MM
                }
                printf "%s%s\n", B_MR, RESET
            }

            printf "%s", PAD_STR
            if (BORDER_STYLE != "mdcat") printf "%s%s%s", S_BORDER, B_L, RESET

            for (i=1; i<=num_cols; i++) {
                val = data[r, i]
                diff = col_widths[i] - visible_length(val)
                printf "%s %s%s%s%s%s%s ", S_CELL_BG, S_CELL_TXT, val, RESET, S_CELL_BG, repeat(" ", diff), RESET
                if (i < num_cols) {
                    if (BORDER_STYLE == "mdcat") printf "%s%s%s", S_BORDER, B_L, RESET
                    else printf "%s%s%s", S_BORDER, B_M, RESET
                }
            }
            if (BORDER_STYLE != "mdcat") printf "%s%s%s", S_BORDER, B_R, RESET
            print ""
        }

        if (BORDER_STYLE != "mdcat") {
            printf "%s%s%s", PAD_STR, S_BORDER, B_BL
            for (i=1; i<=num_cols; i++) {
                printf "%s", repeat(B_B, col_widths[i]+2)
                if (i < num_cols) printf "%s", B_BM
            }
            printf "%s%s\n", B_BR, RESET
        }
    }'
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    cmd_table "${@}"
fi
